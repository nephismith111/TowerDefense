<!DOCTYPE html>
<html>
<head>
    <title>Advanced Tower Defense</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        body {
            background: #1e272e;
            color: #ecf0f1;
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border: 2px solid #2f3640;
            background: #2f3640;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.7);
            margin-bottom: 20px;
        }
        #gameControls {
            margin: 15px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .info {
            background: #2f3640;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            gap: 30px;
            font-size: 18px;
        }
        button {
            background: #00a8ff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 16px;
        }
        button:hover {
            background: #0097e6;
        }
        button:disabled {
            background: #7f8fa6;
            cursor: not-allowed;
        }
        .tower-info {
            font-size: 14px;
            color: #dcdde1;
            text-align: center;
            margin-top: 5px;
        }
    </style>
    <!-- Include Font Awesome for icons -->
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="info">
        <div>üí∞ Money: <span id="money">150</span></div>
        <div>‚ù§Ô∏è Lives: <span id="lives">15</span></div>
        <div>üåä Wave: <span id="wave">1</span></div>
    </div>
    <div id="gameControls">
        <div>
            <button onclick="gameState.selectTower('basic')">Basic Tower ($50)</button>
            <div class="tower-info">üîµ Balanced tower</div>
        </div>
        <div>
            <button onclick="gameState.selectTower('sniper')">Sniper Tower ($100)</button>
            <div class="tower-info">üî¥ High damage</div>
        </div>
        <div>
            <button onclick="gameState.selectTower('rapid')">Rapid Tower ($75)</button>
            <div class="tower-info">üü° Fast firing</div>
        </div>
        <div>
            <button onclick="gameState.selectTower('slow')">Slow Tower ($80)</button>
            <div class="tower-info">üü¢ Slows enemies</div>
        </div>
        <div>
            <button onclick="gameState.startWave()">Start Wave</button>
        </div>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Grid settings
        const GRID_SIZE = 40;
        const GRID_COLS = Math.floor(canvas.width / GRID_SIZE);
        const GRID_ROWS = Math.floor(canvas.height / GRID_SIZE);

        // Tower types configuration
        const TowerTypes = {
            basic: {
                cost: 50,
                range: 100,
                damage: 10,
                fireRate: 1000,
                color: '#3498db',
                name: 'Basic'
            },
            sniper: {
                cost: 100,
                range: 200,
                damage: 30,
                fireRate: 2000,
                color: '#e74c3c',
                name: 'Sniper'
            },
            rapid: {
                cost: 75,
                range: 80,
                damage: 5,
                fireRate: 400,
                color: '#f1c40f',
                name: 'Rapid'
            },
            slow: {
                cost: 80,
                range: 90,
                damage: 0,
                fireRate: 0,
                slowEffect: 0.5, // Reduces enemy speed by 50%
                color: '#2ecc71',
                name: 'Slow'
            }
        };

        // Enemy types configuration
        const EnemyTypes = {
            basic: {
                speed: 1,
                health: 30,
                value: 10,
                color: '#e74c3c',
                size: 10
            },
            fast: {
                speed: 2,
                health: 40,
                value: 15,
                color: '#27ae60',
                size: 8
            },
            tank: {
                speed: 0.5,
                health: 100,
                value: 25,
                color: '#8e44ad',
                size: 15
            },
            stunner: {
                speed: 2.5,
                health: 400,
                value: 40,
                color: '#f39c12',
                size: 12,
                stunRadius: 80,
                stunDuration: 10000 // in milliseconds
            }
        };

        const GameStates = {
            WAITING: 'waiting',
            WAVE_IN_PROGRESS: 'waveInProgress',
            PLACING_TOWER: 'placingTower',
            GAME_OVER: 'gameOver'
        };

        const pathPoints = [
            {x: 0, y: 120},
            {x: 120, y: 120},
            {x: 120, y: 480},
            {x: 480, y: 480},
            {x: 480, y: 120},
            {x: 600, y: 120}
        ];

        class GameState {
            constructor() {
                this.state = GameStates.WAITING;
                this.towers = [];
                this.enemies = [];
                this.projectiles = [];
                this.money = 150;
                this.lives = 15;
                this.wave = 1;
                this.enemiesSpawned = 0;
                this.maxEnemiesPerWave = 80;
                this.lastSpawnTime = 0;
                this.spawnInterval = 500;
                this.selectedTowerType = null;
                this.grid = this.createGrid();
            }

            createGrid() {
                const grid = [];
                for (let y = 0; y < GRID_ROWS; y++) {
                    grid[y] = [];
                    for (let x = 0; x < GRID_COLS; x++) {
                        grid[y][x] = {
                            tower: null,
                            isPath: this.isPathTile(x, y)
                        };
                    }
                }
                return grid;
            }

            isPathTile(x, y) {
                // Simple check to see if the grid square is on the path
                const px = x * GRID_SIZE + GRID_SIZE / 2;
                const py = y * GRID_SIZE + GRID_SIZE / 2;
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p1 = pathPoints[i];
                    const p2 = pathPoints[i + 1];
                    if (this.pointOnLineSegment(p1, p2, {x: px, y: py}, 20)) {
                        return true;
                    }
                }
                return false;
            }

            pointOnLineSegment(p1, p2, pt, tolerance) {
                const d1 = Math.hypot(pt.x - p1.x, pt.y - p1.y);
                const d2 = Math.hypot(pt.x - p2.x, pt.y - p2.y);
                const lineLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                const buffer = tolerance || 0.1;
                return d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer;
            }

            selectTower(type) {
                if (this.money >= TowerTypes[type].cost) {
                    this.selectedTowerType = type;
                    this.state = GameStates.PLACING_TOWER;
                }
            }

            startWave() {
                if (this.state === GameStates.WAITING) {
                    this.state = GameStates.WAVE_IN_PROGRESS;
                    this.enemiesSpawned = 0;
                    this.spawnInterval = Math.max(300, 1000 - (this.wave * 50));
                    this.maxEnemiesPerWave = 8 + (this.wave * 10);
                }
            }

            spawnEnemy() {
                if (this.enemiesSpawned < this.maxEnemiesPerWave) {
                    let type = 'basic';
                    const roll = Math.random();
                    if (this.wave >= 3) {
                        if (roll < 0.2) type = 'fast';
                        else if (roll < 0.35) type = 'tank';
                        else if (roll < 0.45) type = 'stunner';
                    }
                    this.enemies.push(new Enemy(type));
                    this.enemiesSpawned++;
                }
            }

            update() {
                if (this.state === GameStates.WAVE_IN_PROGRESS) {
                    const currentTime = Date.now();
                    if (currentTime - this.lastSpawnTime > this.spawnInterval) {
                        this.spawnEnemy();
                        this.lastSpawnTime = currentTime;
                    }
                }

                if (this.enemiesSpawned >= this.maxEnemiesPerWave &&
                    this.enemies.length === 0 &&
                    this.state === GameStates.WAVE_IN_PROGRESS) {
                    this.wave++;
                    this.state = GameStates.WAITING;
                    this.money += 50 + (this.wave * 10);
                }

                this.enemies.forEach(enemy => enemy.update());
                this.enemies = this.enemies.filter(enemy => !enemy.shouldRemove);

                this.towers.forEach(tower => tower.update(this.enemies));

                this.projectiles.forEach(projectile => projectile.update());
                this.projectiles = this.projectiles.filter(projectile => !projectile.shouldRemove);

                document.getElementById('money').textContent = this.money;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('wave').textContent = this.wave;

                if (this.lives <= 0) {
                    this.state = GameStates.GAME_OVER;
                }
            }

            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                for (let y = 0; y < GRID_ROWS; y++) {
                    for (let x = 0; x < GRID_COLS; x++) {
                        const gridCell = this.grid[y][x];
                        ctx.strokeStyle = gridCell.isPath ? '#95a5a6' : '#7f8c8d';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }

                // Draw path
                ctx.beginPath();
                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                pathPoints.forEach(point => ctx.lineTo(point.x, point.y));
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 30;
                ctx.stroke();

                // Draw tower range preview
                if (this.state === GameStates.PLACING_TOWER && this.selectedTowerType) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = mousePosX - rect.left;
                    const mouseY = mousePosY - rect.top;
                    const towerType = TowerTypes[this.selectedTowerType];

                    const gridX = Math.floor(mouseX / GRID_SIZE);
                    const gridY = Math.floor(mouseY / GRID_SIZE);

                    if (this.canPlaceTower(gridX, gridY)) {
                        const centerX = gridX * GRID_SIZE + GRID_SIZE / 2;
                        const centerY = gridY * GRID_SIZE + GRID_SIZE / 2;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, towerType.range, 0, Math.PI * 2);
                        ctx.strokeStyle = `${towerType.color}88`;
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
                        ctx.fillStyle = towerType.color;
                        ctx.fill();
                    }
                }

                this.towers.forEach(tower => tower.draw());
                this.enemies.forEach(enemy => enemy.draw());
                this.projectiles.forEach(projectile => projectile.draw());

                if (this.state === GameStates.GAME_OVER) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ecf0f1';
                    ctx.font = 'bold 48px Roboto';
                    ctx.textAlign = 'center';
                    ctx.fillText('Game Over!', canvas.width/2, canvas.height/2 - 30);
                    ctx.font = '24px Roboto';
                    ctx.fillText(`Final Wave: ${this.wave}`, canvas.width/2, canvas.height/2 + 20);
                }
            }

            canPlaceTower(x, y) {
                if (x < 0 || x >= GRID_COLS || y < 0 || y >= GRID_ROWS) return false;
                const cell = this.grid[y][x];
                return !cell.isPath && cell.tower === null;
            }

            placeTower(x, y) {
                if (this.canPlaceTower(x, y)) {
                    const towerType = TowerTypes[this.selectedTowerType];
                    if (this.money >= towerType.cost) {
                        const centerX = x * GRID_SIZE + GRID_SIZE / 2;
                        const centerY = y * GRID_SIZE + GRID_SIZE / 2;
                        const tower = new Tower(centerX, centerY, this.selectedTowerType);
                        this.towers.push(tower);
                        this.money -= towerType.cost;
                        this.grid[y][x].tower = tower;
                        this.state = GameStates.WAITING;
                        this.selectedTowerType = null;
                    }
                }
            }
        }

        class Tower {
            constructor(x, y, type) {
                const config = TowerTypes[type];
                this.x = x;
                this.y = y;
                this.type = type;
                this.range = config.range;
                this.damage = config.damage;
                this.fireRate = config.fireRate;
                this.color = config.color;
                this.lastShot = 0;
                this.angle = 0;
                this.target = null;
                this.slowEffect = config.slowEffect || null;
                this.stunned = false;
                this.stunEndTime = 0;
            }

            update(enemies) {
                if (this.stunned) {
                    if (Date.now() > this.stunEndTime) {
                        this.stunned = false;
                    } else {
                        return; // Skip updating if stunned
                    }
                }

                if (this.type === 'slow') {
                    // Apply slow effect to enemies in range
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (dist <= this.range) {
                            enemy.applySlow(this.slowEffect);
                        }
                    });
                } else {
                    const currentTime = Date.now();
                    if (currentTime - this.lastShot > this.fireRate) {
                        // Find closest enemy in range
                        let closestDist = Infinity;
                        this.target = null;

                        enemies.forEach(enemy => {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist <= this.range && dist < closestDist) {
                                closestDist = dist;
                                this.target = enemy;
                            }
                        });

                        if (this.target) {
                            this.angle = Math.atan2(
                                this.target.y - this.y,
                                this.target.x - this.x
                            );

                            gameState.projectiles.push(new Projectile(
                                this.x, this.y,
                                this.target,
                                this.damage,
                                this.type
                            ));
                            this.lastShot = currentTime;
                        }
                    }
                }
            }

            stun(duration) {
                this.stunned = true;
                this.stunEndTime = Date.now() + duration;
            }

            draw() {
                // Draw tower body
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fillStyle = this.stunned ? '#7f8c8d' : this.color;
                ctx.fill();

                if (this.type !== 'slow') {
                    // Draw tower cannon
                    ctx.beginPath();
                    ctx.rect(0, -5, 20, 10);
                    ctx.fillStyle = this.stunned ? '#95a5a6' : this.color;
                    ctx.fill();
                } else {
                    // Draw slow effect aura
                    ctx.beginPath();
                    ctx.arc(0, 0, this.range, 0, Math.PI * 2);
                    ctx.strokeStyle = `${this.color}88`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Enemy {
            constructor(type) {
                const config = EnemyTypes[type];
                this.type = type;
                this.pathIndex = 0;
                this.x = pathPoints[0].x;
                this.y = pathPoints[0].y;
                this.speed = config.speed;
                this.baseSpeed = config.speed;
                this.maxHealth = config.health;
                this.health = config.health;
                this.value = config.value;
                this.color = config.color;
                this.size = config.size;
                this.shouldRemove = false;
                this.slowed = false;
                this.slowEndTime = 0;
                this.stunRadius = config.stunRadius || null;
                this.stunDuration = config.stunDuration || null;
            }

            applySlow(effect) {
                if (!this.slowed) {
                    this.speed *= effect;
                    this.slowed = true;
                    this.slowEndTime = Date.now() + 2000; // Slow effect lasts for 2 seconds
                }
            }

            update() {
                if (this.slowed) {
                    if (Date.now() > this.slowEndTime) {
                        this.speed = this.baseSpeed;
                        this.slowed = false;
                    }
                }

                if (this.pathIndex < pathPoints.length - 1) {
                    const targetPoint = pathPoints[this.pathIndex + 1];
                    const dx = targetPoint.x - this.x;
                    const dy = targetPoint.y - this.y;
                    const distance = Math.hypot(dx, dy);

                    if (distance < this.speed) {
                        this.pathIndex++;
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }

                if (this.pathIndex === pathPoints.length - 1) {
                    this.shouldRemove = true;
                    gameState.lives--;
                }

                if (this.health <= 0) {
                    this.shouldRemove = true;
                    gameState.money += this.value;
                }

                if (this.type === 'stunner' && !this.hasStunned) {
                    // Stun towers within radius
                    this.stunTowers();
                    // this.hasStunned = true;
                }
            }

            stunTowers() {
                gameState.towers.forEach(tower => {
                    const dist = Math.hypot(tower.x - this.x, tower.y - this.y);
                    if (dist <= this.stunRadius) {
                        tower.stun(this.stunDuration);
                    }
                });
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Health bar background
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(this.x - 15, this.y - (this.size + 10), 30, 4);

                // Health bar
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(
                    this.x - 15,
                    this.y - (this.size + 10),
                    (this.health / this.maxHealth) * 30,
                    4
                );
            }
        }

        class Projectile {
            constructor(startX, startY, target, damage, towerType) {
                this.x = startX;
                this.y = startY;
                this.target = target;
                this.damage = damage;
                this.shouldRemove = false;
                this.size = towerType === 'sniper' ? 4 : 3;
                this.color = TowerTypes[towerType].color;
                this.speed = towerType === 'sniper' ? 10 : 5;
            }

            update() {
                if (this.target.shouldRemove) {
                    this.shouldRemove = true;
                    return;
                }

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distance = Math.hypot(dx, dy);

                if (distance < this.speed) {
                    // Hit the enemy
                    this.target.health -= this.damage;
                    this.shouldRemove = true;
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // Game setup
        const gameState = new GameState();
        let mousePosX = 0;
        let mousePosY = 0;

        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            mousePosX = e.clientX;
            mousePosY = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (gameState.state === GameStates.PLACING_TOWER && gameState.selectedTowerType) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const gridX = Math.floor(mouseX / GRID_SIZE);
                const gridY = Math.floor(mouseY / GRID_SIZE);

                gameState.placeTower(gridX, gridY);
            }
        });

        // Game loop
        function gameLoop() {
            gameState.update();
            gameState.draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>